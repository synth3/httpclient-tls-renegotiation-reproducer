/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package httpclient.tls.renegotiation.reproducer;

import org.apache.hc.client5.http.async.methods.SimpleHttpRequest;
import org.apache.hc.client5.http.async.methods.SimpleHttpRequests;
import org.apache.hc.client5.http.async.methods.SimpleHttpResponse;
import org.apache.hc.client5.http.async.methods.SimpleResponseConsumer;
import org.apache.hc.client5.http.config.RequestConfig;
import org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient;
import org.apache.hc.client5.http.impl.async.HttpAsyncClientBuilder;
import org.apache.hc.client5.http.impl.async.HttpAsyncClients;
import org.apache.hc.client5.http.impl.nio.PoolingAsyncClientConnectionManagerBuilder;
import org.apache.hc.client5.http.nio.AsyncClientConnectionManager;
import org.apache.hc.client5.http.protocol.HttpClientContext;
import org.apache.hc.client5.http.ssl.ClientTlsStrategyBuilder;
import org.apache.hc.client5.http.ssl.HttpsSupport;
import org.apache.hc.client5.http.ssl.NoopHostnameVerifier;
import org.apache.hc.core5.http.nio.ssl.TlsStrategy;
import org.apache.hc.core5.http.nio.support.BasicRequestProducer;
import org.apache.hc.core5.http2.HttpVersionPolicy;
import org.apache.hc.core5.io.CloseMode;
import org.apache.hc.core5.pool.PoolConcurrencyPolicy;
import org.apache.hc.core5.pool.PoolReusePolicy;
import org.apache.hc.core5.reactor.IOReactorConfig;
import org.apache.hc.core5.ssl.SSLContexts;
import org.apache.hc.core5.util.TimeValue;
import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.Level;
import org.apache.log4j.PatternLayout;
import org.junit.After;
import org.junit.Before;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.net.ssl.SSLContext;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.concurrent.TimeUnit;


public class Test
{
    private static final Logger LOGGER = LoggerFactory.getLogger(Test.class);

    private static final String URL_TLS_RENEGOTIATION = "https://localhost:8443/withclientcert/test2.html";
    private static final String URL_TLS = "https://localhost:8443/test1.html";
    private AsyncClientConnectionManager mConnectionManager = null;
    private CloseableHttpAsyncClient mHTTPClient;

    @Before
    public void setup() throws Exception
    {
        System.setProperty("javax.net.debug", "all");
        setupLog4J();

        // TrustStrategy that does no checks on the server certs
        SSLContext sslCtx = SSLContexts.custom().loadTrustMaterial(null, (certificate, authType) -> true).build();
        // sslCBuilder.loadTrustMaterial(trustStore, truststore-pw)

        final TlsStrategy tlsStrategy = ClientTlsStrategyBuilder.create() //
                .setSslContext(sslCtx) //
                .setTlsVersions(HttpsSupport.getSystemProtocols()) //
                .setHostnameVerifier(NoopHostnameVerifier.INSTANCE) // do not verify server hostname
                .setCiphers(HttpsSupport.getSystemCipherSuits()).build();

        mConnectionManager = PoolingAsyncClientConnectionManagerBuilder.create() //
                .setTlsStrategy(tlsStrategy) //
                .setMaxConnTotal(1) //
                .setConnPoolPolicy(PoolReusePolicy.LIFO) //
                .setPoolConcurrencyPolicy(PoolConcurrencyPolicy.STRICT) // will not exceed set limits
                .setValidateAfterInactivity(TimeValue.ofMinutes(1)) // when not set inactive connections will not be validated
                .setConnectionTimeToLive(TimeValue.ofMinutes(5)) // when not set/null then connections will be kept forever (until invalid...)
                .build();

        final RequestConfig defaultRequestConfig = RequestConfig.custom() //
                .setResponseTimeout(20, TimeUnit.SECONDS) //
                .setConnectTimeout(20, TimeUnit.SECONDS) //
                .setConnectionRequestTimeout(5, TimeUnit.SECONDS) //
                .build();

        final IOReactorConfig ioReactorConfig = IOReactorConfig.custom() //
                .setSoTimeout(20, TimeUnit.SECONDS) //
                .build();

        HttpAsyncClientBuilder clientBuilder = HttpAsyncClients.custom() //
                .setConnectionManager(mConnectionManager) //
                .setDefaultRequestConfig(defaultRequestConfig) //
                .setIOReactorConfig(ioReactorConfig) //
                .setVersionPolicy(HttpVersionPolicy.FORCE_HTTP_1);

        mHTTPClient = clientBuilder.build();
        mHTTPClient.start();
    }

    @After
    public void tearDown()
    {
        mHTTPClient.close(CloseMode.IMMEDIATE);
        mConnectionManager.close(CloseMode.IMMEDIATE);
    }

    @org.junit.Test
    public void testTLSRenegotiateHC5() throws Exception
    {
        LOGGER.warn("testTLSRenegotiateHC5");
        SimpleHttpRequest request = SimpleHttpRequests.get(URL_TLS_RENEGOTIATION);
        SimpleHttpResponse response = mHTTPClient
                .execute(new BasicRequestProducer(request, null), SimpleResponseConsumer.create(), HttpClientContext.create(), null)
                .get();
        LOGGER.warn("Received response: {}",response.getBodyText());
    }

    @org.junit.Test
    public void testTLSRegularHC5() throws Exception
    {
        LOGGER.warn("testTLSRegularHC5");
        SimpleHttpRequest request = SimpleHttpRequests.get(URL_TLS);
        SimpleHttpResponse response = mHTTPClient
                .execute(new BasicRequestProducer(request, null), SimpleResponseConsumer.create(), HttpClientContext.create(), null)
                .get();
        LOGGER.warn("Received response: {}",response.getBodyText());
    }

    @org.junit.Test
    public void testTLSRenegotiateJavaHttpClient() throws Exception
    {
        LOGGER.warn("testTLSRenegotiateJavaHttpClient");
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(URL_TLS_RENEGOTIATION))
                .timeout(Duration.ofMinutes(1))
                .GET().build();

        HttpClient client = HttpClient
                .newBuilder()
                .version(HttpClient.Version.HTTP_1_1)
                .sslContext(SSLContexts
                        .custom()
                        .loadTrustMaterial(null, (certificate, authType) -> true)
                        .build())
                .build();

        client.sendAsync(request, HttpResponse.BodyHandlers.ofString())
                .thenApply(HttpResponse::body)
                .thenAccept(result -> LOGGER.warn("Received response: {}", result))
                .join();
    }

    private void setupLog4J()
    {
        ConsoleAppender console = new ConsoleAppender();
//      String PATTERN = "%d %-5p %l [%t]  %m%n";
        String PATTERN = "[%d{ISO8601}] %-5p %m%n";
        console.setLayout(new PatternLayout(PATTERN));
        console.setThreshold(Level.DEBUG);
        console.activateOptions();
        console.setName("Test console appender.");
        org.apache.log4j.Logger.getRootLogger().addAppender(console);
    }
}
